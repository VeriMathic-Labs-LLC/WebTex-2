/*  src/app.js  – compiled → build/app.js
    Enhanced WebTeX with KaTeX + MathJax fallback + custom parser
*/
import './app.css';
import katex from 'katex';
import 'katex/dist/katex.min.css';

/* -------------------------------------------------- */
// Reusable entity decoder for performance
function decodeHTMLEntities(text) {
  return text.replace(/&amp;/g, '&')
             .replace(/&lt;/g, '<')
             .replace(/&gt;/g, '>')
             .replace(/&quot;/g, '"')
             .replace(/&#39;/g, "'");
}

/* -------------------------------------------------- */
let observer = null;
let isEnabled = false;
let mathjaxLoaded = false;
let katexLoaded = true; // KaTeX is bundled
let rendererState = {
  katexSuccess: 0,
  mathjaxFallback: 0,
  customParserFallback: 0,
  totalAttempts: 0
};

// Expose renderer state globally for debugging
window.rendererState = rendererState;

// Enhanced MathJax configuration
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'input', 'select', 'button'],
    ignoreHtmlClass: 'webtex-ignore',
    processHtmlClass: 'webtex-process'
  },
  startup: {
    typeset: false,
    ready: () => {
      mathjaxLoaded = true;
      console.log('WebTeX: MathJax is ready for fallback rendering.');
      if (isEnabled) {
        safeRender();
      }
      window.MathJax.startup.defaultReady();
    }
  }
};

// Load MathJax for fallback
const script = document.createElement('script');
script.type = 'text/javascript';
script.src = chrome.runtime.getURL('mathjax/es5/tex-chtml-full.js');
script.async = true;
document.head.appendChild(script);

/* -------------------------------------------------- */
// Enhanced Custom LaTeX Parser for edge cases
class CustomLatexParser {
  constructor() {
    this.supportedEnvironments = [
      'matrix', 'pmatrix', 'bmatrix', 'vmatrix', 'Vmatrix',
      'array', 'align', 'aligned', 'gather', 'gathered',
      'cases', 'split', 'multline', 'eqnarray'
    ];
  }

  // Check if expression can be handled by custom parser
  canHandle(tex) {
    // Always try the custom parser for common patterns
    return tex.includes('\\text{') || 
           tex.includes('rac') || 
           tex.includes('\\begin{equation}') || 
           tex.includes('\\begin{align}') ||
           tex.includes('\\to') ||
           tex.includes('^{A}') ||
           tex.includes('_{Z}') ||
           tex.includes('\\begin{matrix}') || 
           tex.includes('\\begin{pmatrix}') ||
           tex.includes('\\begin{cases}');
  }

  // Convert to simplified LaTeX that KaTeX can handle
  simplify(tex) {
    let simplified = tex;
    
    // Process fractions
    simplified = this.processFractionNotation(simplified);
    
    // Process nuclear notation BEFORE other replacements
    simplified = this.processNuclearNotation(simplified);
    
    // Process environments
    simplified = this.processEquationEnvironments(simplified);
    simplified = this.processAlignEnvironment(simplified);
    
    // Process arrows and symbols
    simplified = this.processArrows(simplified);
    simplified = this.processLimits(simplified);
    
    // Handle matrix environments
    simplified = simplified.replace(/\\begin\{matrix\}/g, '\\begin{array}');
    simplified = simplified.replace(/\\end\{matrix\}/g, '\\end{array}');
    
    return simplified;
  }

  processFractionNotation(str) {
    // rac{num}{den}
    str = str.replace(/(?:\\f?rac|rac)\{([^}]+)\}\{([^}]+)\}/g, '\\frac{$1}{$2}');
    // rac27 pattern
    str = str.replace(/\brac(\d)(\d+)/g, (_, a, b) => `\\frac{${a}}{${b}}`);
    // standalone rac
    str = str.replace(/\brac\b/g, '\\frac');
    return str;
  }

  processNuclearNotation(str) {
    // Basic nuclear notation: \text{_Z^A X} -> {}^{A}_{Z}\text{X}
    str = str.replace(/\\text\{_(\d+)\^(\d+)\s+([^}]+)\}/g, '{}^{$2}_{$1}\\text{$3}');
    
    // Nuclear notation with variables: \text{_Z^A N} -> {}^{A}_{Z}\text{N}
    str = str.replace(/\\text\{_([A-Z])\^([A-Z])\s+([^}]+)\}/g, '{}^{$2}_{$1}\\text{$3}');
    
    // Complex nuclear notation: \text{{Z-2}^{A-4} N'} -> {}^{A-4}_{Z-2}\text{N'}
    str = str.replace(/\\text\{\{([^}]+)\}\^\{([^}]+)\}\s+([^}]+)\}/g, '{}^{$2}_{$1}\\text{$3}');
    
    // Alternative notation: ^{A}_{Z}\text{N}
    str = str.replace(/\^\{([^}]+)\}_\{([^}]+)\}\\text\{([^}]+)\}/g, '{}^{$1}_{$2}\\text{$3}');
    
    // Already formatted nuclear notation
    str = str.replace(/\\text\{\}\^/g, '{}^');
    
    // e^- and e^+ outside \text{}
    str = str.replace(/\\text\{e\^\-\}/g, 'e^{-}');
    str = str.replace(/\\text\{e\^\+\}/g, 'e^{+}');
    
    // Star notation for excited states
    str = str.replace(/\\text\{([^}]+)\*\}/g, '\\text{$1}^*');
    
    // Handle Z^A and _Z^A without \text{}
    str = str.replace(/([A-Z])\^([A-Z])\s+([A-Z])/g, '{}^{$2}\\text{$3}');
    str = str.replace(/_([A-Z])\^([A-Z])\s+([A-Z])/g, '{}^{$2}_{$1}\\text{$3}');
    
    return str;
  }

  processEquationEnvironments(str) {
    return str.replace(/\\begin\{equation\}([\s\S]*?)\\end\{equation\}/g, '$1');
  }

  processAlignEnvironment(str) {
    return str.replace(/\\begin\{align\}([\s\S]*?)\\end\{align\}/g, '\\begin{aligned}$1\\end{aligned}');
  }

  processArrows(str) {
    str = str.replace(/\\to/g, '\\rightarrow');
    str = str.replace(/→/g, '\\rightarrow');
    return str;
  }

  processLimits(str) {
    // Fix "lim_{x o infty}" -> "lim_{x \to \infty}"
    str = str.replace(/lim_\{([^}]+)\s+o\s+([^}]+)\}/g, '\\lim_{$1 \\to $2}');
    return str;
  }

  // Create a simple fallback rendering
  renderFallback(tex, displayMode = false) {
    const container = document.createElement('span');
    container.className = 'webtex-custom-fallback';
    container.style.cssText = `
      display: ${displayMode ? 'block' : 'inline-block'};
      font-family: 'Computer Modern', serif;
      font-size: 1.1em;
      color: inherit;
      background: rgba(255, 235, 238, 0.3);
      padding: 2px 4px;
      border-radius: 3px;
      border: 1px solid rgba(239, 154, 154, 0.5);
    `;
    container.textContent = tex;
    return container;
  }
}

const customParser = new CustomLatexParser();

/* -------------------------------------------------- */
// Enhanced rendering function with intelligent fallback
async function renderMathExpression(tex, displayMode = false, element = null) {
  rendererState.totalAttempts++;
  
  // Try KaTeX first
  try {
    // Preprocess the LaTeX to handle Unicode characters
    const processedTex = handleUnicodeInMath(tex);
    
    const katexOptions = {
      displayMode: displayMode,
      throwOnError: false,
      errorColor: '#cc0000',
      strict: false, // Disable strict mode to reduce warnings
      trust: true, // Trust input to allow more features
      macros: {
        "\\RR": "\\mathbb{R}",
        "\\NN": "\\mathbb{N}",
        "\\ZZ": "\\mathbb{Z}",
        "\\QQ": "\\mathbb{Q}",
        "\\CC": "\\mathbb{C}",
        "\\half": "\\frac{1}{2}",
        "\\quarter": "\\frac{1}{4}",
        "\\third": "\\frac{1}{3}",
        "\\twothirds": "\\frac{2}{3}",
        "\\threequarters": "\\frac{3}{4}"
      },
      // Handle Unicode characters better
      minRuleThickness: 0.05,
      maxSize: 1000,
      maxExpand: 1000
    };
    
    const rendered = katex.renderToString(processedTex, katexOptions);
    rendererState.katexSuccess++;
    
    if (element) {
      element.innerHTML = rendered;
      element.classList.add('webtex-katex-rendered');
    }
    
    return { success: true, method: 'katex', element: element };
  } catch (katexError) {
    console.debug('WebTeX: KaTeX failed, trying MathJax fallback:', katexError.message);
    
    // Try MathJax fallback
    if (mathjaxLoaded) {
      try {
        if (element) {
          element.className = 'mj';
          element.innerHTML = displayMode ? `\\[${tex}\\]` : `\\(${tex}\\)`;
          
          await window.MathJax.typesetPromise([element]);
          rendererState.mathjaxFallback++;
          element.classList.add('webtex-mathjax-rendered');
          
          return { success: true, method: 'mathjax', element: element };
        }
      } catch (mathjaxError) {
        console.debug('WebTeX: MathJax fallback failed:', mathjaxError.message);
      }
    }
    
    // Try custom parser as last resort
    if (customParser.canHandle(tex)) {
      try {
        const simplified = customParser.simplify(tex);
        const processedSimplified = handleUnicodeInMath(simplified);
        const rendered = katex.renderToString(processedSimplified, { displayMode, throwOnError: false });
        
        if (element) {
          element.innerHTML = rendered;
          element.classList.add('webtex-custom-rendered');
        }
        
        rendererState.customParserFallback++;
        return { success: true, method: 'custom', element: element };
      } catch (customError) {
        console.debug('WebTeX: Custom parser failed:', customError.message);
      }
    }
    
    // Final fallback - show original text with error styling
    if (element) {
      const fallbackElement = customParser.renderFallback(tex, displayMode);
      element.innerHTML = '';
      element.appendChild(fallbackElement);
      element.classList.add('webtex-error-fallback');
    }
    
    return { success: false, method: 'error', element: element };
  }
}

/* -------------------------------------------------- */
// Enhanced math detection and processing
function findMathExpressions(root) {
  const mathExpressions = [];
  const walker = document.createTreeWalker(
    root,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: function(node) {
        // Skip if parent is already processed or should be ignored
        if (node.parentElement && (
          node.parentElement.classList.contains('webtex-processed') ||
          node.parentElement.classList.contains('webtex-ignore') ||
          node.parentElement.closest('.webtex-ignore')
        )) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );

  let node;
  while (node = walker.nextNode()) {
    const text = node.textContent;
    
    // Enhanced regex patterns for math detection
    const patterns = [
      // Display math
      { pattern: /\$\$([\s\S]*?)\$\$/g, display: true },
      { pattern: /\\\[([\s\S]*?)\\\]/g, display: true },
      // Inline math
      { pattern: /\$([^\$\n]+?)\$/g, display: false },
      { pattern: /\\\(([\s\S]*?)\\\)/g, display: false }
    ];

    patterns.forEach(({ pattern, display }) => {
      let match;
      while ((match = pattern.exec(text)) !== null) {
        const tex = decodeHTMLEntities(match[1].trim());
        if (tex) {
          mathExpressions.push({
            tex: tex,
            display: display,
            node: node,
            match: match[0],
            start: match.index,
            end: match.index + match[0].length
          });
        }
      }
    });
  }

  return mathExpressions;
}

/* -------------------------------------------------- */
// Process math expressions with intelligent fallback
async function processMathExpressions(expressions) {
  const processedNodes = new Set();
  
  for (const expr of expressions) {
    if (processedNodes.has(expr.node)) continue;
    
    // Check if node still exists and has a parent
    if (!expr.node || !expr.node.parentNode) {
      console.debug('WebTeX: Skipping orphaned node');
      continue;
    }
    
    const text = expr.node.textContent;
    const container = document.createElement('span');
    container.className = 'webtex-math-container';
    
    // Replace the math expression with a container
    const before = text.substring(0, expr.start);
    const after = text.substring(expr.end);
    
    if (before) {
      container.appendChild(document.createTextNode(before));
    }
    
    const mathElement = document.createElement('span');
    mathElement.className = `webtex-math ${expr.display ? 'webtex-display' : 'webtex-inline'}`;
    
    const result = await renderMathExpression(expr.tex, expr.display, mathElement);
    
    if (result.success) {
      container.appendChild(mathElement);
    } else {
      // Keep original text if all renderers failed
      container.appendChild(document.createTextNode(expr.match));
    }
    
    if (after) {
      container.appendChild(document.createTextNode(after));
    }
    
    // Double-check parent exists before replacing
    if (expr.node.parentNode) {
      expr.node.parentNode.replaceChild(container, expr.node);
      processedNodes.add(expr.node);
    }
  }
}

/* -------------------------------------------------- */
// Enhanced preprocessing with Unicode handling
function preprocessMathText(node) {
  if (!node || !node.childNodes) return;
  
  node.childNodes.forEach(child => {
    if (child.nodeType === 3) { // Text node
      let text = child.textContent;
      text = decodeHTMLEntities(text);
      
      // Enhanced environment handling
      text = text.replace(/\$\s*\\begin\{([^}]+)\}([\s\S]*?)\\end\{\1\}\s*\$/g, (m, env, content) => {
        const decodedContent = decodeHTMLEntities(content);
        return '$$\\begin{' + env + '}' + decodedContent + '\\end{' + env + '}$$';
      });
      
      child.textContent = text;
    } else if (child.nodeType === 1 && !["SCRIPT","STYLE","TEXTAREA","PRE","CODE","NOSCRIPT","INPUT","SELECT","BUTTON"].includes(child.tagName)) {
      preprocessMathText(child);
    }
  });
}

// Function to handle Unicode characters in math expressions
function handleUnicodeInMath(tex) {
  // Common Unicode fractions
  const unicodeFractions = {
    '½': '\\frac{1}{2}',
    '⅓': '\\frac{1}{3}',
    '⅔': '\\frac{2}{3}',
    '¼': '\\frac{1}{4}',
    '¾': '\\frac{3}{4}',
    '⅕': '\\frac{1}{5}',
    '⅖': '\\frac{2}{5}',
    '⅗': '\\frac{3}{5}',
    '⅘': '\\frac{4}{5}',
    '⅙': '\\frac{1}{6}',
    '⅚': '\\frac{5}{6}',
    '⅐': '\\frac{1}{7}',
    '⅛': '\\frac{1}{8}',
    '⅜': '\\frac{3}{8}',
    '⅝': '\\frac{5}{8}',
    '⅞': '\\frac{7}{8}',
    '⅑': '\\frac{1}{9}',
    '⅒': '\\frac{1}{10}'
  };
  
  let processed = tex;
  
  // Replace Unicode fractions with LaTeX fractions
  Object.entries(unicodeFractions).forEach(([unicode, latex]) => {
    processed = processed.replace(new RegExp(unicode, 'g'), latex);
  });
  
  // Handle other Unicode characters by wrapping them in \text{}
  // This regex matches Unicode characters that are not already in \text{} or other commands
  processed = processed.replace(/([^\u0000-\u007F])/g, (match, char) => {
    // Skip if already in \text{} or other commands
    if (processed.includes(`\\text{${char}}`) || 
        processed.includes(`\\mathrm{${char}}`) ||
        processed.includes(`\\mathit{${char}}`)) {
      return char;
    }
    return `\\text{${char}}`;
  });
  
  return processed;
}

/* -------------------------------------------------- */
// Main rendering function
async function safeRender(root = document.body) {
  if (!isEnabled) return;
  
  try {
    preprocessMathText(root);
    
    const expressions = findMathExpressions(root);
    if (expressions.length > 0) {
      await processMathExpressions(expressions);
      
      // Log rendering statistics
      console.log('WebTeX: Rendering complete', {
        total: rendererState.totalAttempts,
        katex: rendererState.katexSuccess,
        mathjax: rendererState.mathjaxFallback,
        custom: rendererState.customParserFallback,
        successRate: ((rendererState.katexSuccess + rendererState.mathjaxFallback + rendererState.customParserFallback) / rendererState.totalAttempts * 100).toFixed(1) + '%'
      });
    }
  } catch (e) {
    console.error('WebTeX: Error during rendering', e);
  }
}

/* -------------------------------------------------- */
// Main initialization
(async function main() {
  const { allowedDomains = [] } = await chrome.storage.local.get("allowedDomains");
  
  const isLocalFile = location.protocol === 'file:';
  const isDomainAllowed = allowedDomains.includes(location.hostname);
  
  isEnabled = isLocalFile || isDomainAllowed;
  
  if (isEnabled) {
    enableRendering();
  }

  // Listen for domain updates
  chrome.runtime.onMessage.addListener(msg => {
    if (msg.action === "domain-updated" && msg.allowed) {
      const newIsEnabled = location.protocol === 'file:' || msg.allowed.includes(location.hostname);
      
      if (newIsEnabled && !isEnabled) {
        isEnabled = true;
        enableRendering();
        setupNavigationHandlers();
      } else if (!newIsEnabled && isEnabled) {
        isEnabled = false;
        disableRendering();
      }
    }
  });

  setupNavigationHandlers();
})();

/* -------------------------------------------------- */
// Navigation and observer setup
let navigationHandlersSetup = false;

function setupNavigationHandlers() {
  if (!isEnabled || navigationHandlersSetup) return;
  
  navigationHandlersSetup = true;
  let lastUrl = location.href;
  
  const debouncedNavigationHandler = debounce(handleNavigation, 100);

  const navigationObserver = new MutationObserver(() => {
    if (location.href !== lastUrl) {
      lastUrl = location.href;
      debouncedNavigationHandler();
    }
  });

  navigationObserver.observe(document.body, { childList: true, subtree: true });
  window.addEventListener('popstate', debouncedNavigationHandler);
}

function handleNavigation() {
  if (!isEnabled) return;
  console.debug('WebTeX: Detected navigation, re-rendering math');
  safeRender();
}

function enableRendering() {
  safeRender();

  observer = new MutationObserver(debounce(muts => {
    if (mutationsOnlyRipple(muts) || userIsSelectingText() || typingInsideActiveElement(muts)) {
      return;
    }

    muts.flatMap(m => [...m.addedNodes])
        .filter(n => n.nodeType === 1 && !n.closest('.webtex-ignore'))
        .forEach(safeRender);
  }, 200));
  
  observer.observe(document.body, { childList: true, subtree: true });
}

function disableRendering() {
  if (observer) {
    observer.disconnect();
    observer = null;
  }
  
  if (window.MathJax && window.MathJax.typesetClear) {
    window.MathJax.typesetClear();
  }
  
  // Clear KaTeX rendered elements
  document.querySelectorAll('.webtex-katex-rendered, .webtex-mathjax-rendered, .webtex-custom-rendered').forEach(el => {
    el.classList.remove('webtex-katex-rendered', 'webtex-mathjax-rendered', 'webtex-custom-rendered');
  });
}

/* -------------------------------------------------- */
// Helper functions
function nodeIsEditable(n) {
  if (n.getAttribute && n.getAttribute('contenteditable') === 'false') return false;
  return n.isContentEditable || (n.nodeType === 1 && /^(INPUT|TEXTAREA|SELECT)$/.test(n.tagName));
}

function typingInsideActiveElement(muts) {
  const active = document.activeElement;
  if (!active || !nodeIsEditable(active)) return false;
  return muts.every(m => active.contains(m.target));
}

function userIsSelectingText() {
  const sel = document.getSelection();
  return sel && sel.rangeCount > 0 && !sel.isCollapsed;
}

function isRippleNode(n) {
  return n.nodeType === 1 && n.classList && (
    n.classList.contains("mat-ripple") ||
    n.classList.contains("mdc-button__ripple") ||
    n.classList.contains("mat-focus-indicator")
  );
}

function mutationsOnlyRipple(muts) {
  return muts.every(m =>
    [...m.addedNodes, ...m.removedNodes].every(isRippleNode)
  );
}

function debounce(fn, ms) {
  let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); };
}
