<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebTeX Problematic LaTeX Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #007acc;
            padding-bottom: 5px;
        }
        .webtex-inline-math {
            display: inline;
            vertical-align: middle;
        }
        .webtex-display-math {
            display: block;
            text-align: center;
            margin: 1em 0;
        }
        .webtex-processed {
            display: inline;
        }
        .formula {
            background-color: white;
            padding: 10px;
            border-left: 4px solid #007acc;
            margin: 10px 0;
        }
        .description {
            font-style: italic;
            color: #666;
            margin-top: 5px;
        }
        .problematic {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .success {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
    </style>
</head>
<body>
    <h1>WebTeX Enhanced LaTeX Renderer - Problematic Expressions Test</h1>
    
    <div class="test-section">
        <h3>Problematic Expressions (Before Fix)</h3>
        
        <div class="formula problematic">
            <strong>Malformed Expression:</strong> $L=-1N∑(}(y p()+(1-y) (1-p())) $
            <div class="description">This was the problematic expression that wasn't rendering correctly.</div>
        </div>

        <div class="formula problematic">
            <strong>Another Malformed Expression:</strong> $x^{2+3} + y_{i,j} + \frac{a}{b} + \sqrt{c}$
            <div class="description">Testing complex expressions with nested braces.</div>
        </div>
    </div>

    <div class="test-section">
        <h3>Nuclear Physics Formulas (Chapter 29) - Fixed</h3>
        
        <div class="formula success">
            <strong>Neutron Number:</strong> $N = A - Z$
            <div class="description">Where N is the neutron number, A is the atomic mass number (number of nucleons), and Z is the atomic number (number of protons).</div>
        </div>

        <div class="formula success">
            <strong>Nuclide Symbolization:</strong> $^{A}_{Z}X$
            <div class="description">Where X is the chemical symbol for the element, A is the atomic mass number, and Z is the atomic number.</div>
        </div>

        <div class="formula success">
            <strong>Nucleus Radius:</strong> $r \approx (1.2 \times 10^{-15} \text{ m})(A^{1/3})$
            <div class="description">This formula provides an approximate radius of a nucleus based on its atomic mass number A.</div>
        </div>

        <div class="formula success">
            <strong>Unified Atomic Mass Unit (u) Conversions:</strong><br>
            $1 \text{ u} = 1.6605 \times 10^{-27} \text{ kg}$<br>
            $1 \text{ u} = 931.5 \text{ MeV/c}^2$
            <div class="description">These are conversion factors for the unified atomic mass unit, which is used to measure the masses of atoms.</div>
        </div>

        <div class="formula success">
            <strong>General Alpha Decay:</strong> $^{A}_{Z}\text{N} \rightarrow ^{A-4}_{Z-2}\text{N'} + ^{4}_{2}\text{He}$
            <div class="description">This represents the decay of a parent nucleus N into a daughter nucleus N' and an alpha particle ($^{4}_{2}\text{He}$).</div>
        </div>

        <div class="formula success">
            <strong>General Beta-Minus Decay:</strong> $^{A}_{Z}\text{N} \rightarrow ^{A}_{Z+1}\text{N'} + \text{e}^- + \bar{\nu}$
            <div class="description">This shows a parent nucleus N decaying into a daughter nucleus N', an electron (e⁻), and an antineutrino ($\bar{\nu}$).</div>
        </div>
    </div>

    <div class="test-section">
        <h3>Complex Mathematical Expressions</h3>
        
        <div class="formula success">
            <strong>Complex Fractions:</strong> $\frac{a + b}{c + d} + \frac{x^2 + y^2}{z^2}$
        </div>

        <div class="formula success">
            <strong>Nested Subscripts/Superscripts:</strong> $x^{2^{3}} + y_{i_{j}} + z^{a}_{b}$
        </div>

        <div class="formula success">
            <strong>Mixed Expressions:</strong> $\sum_{i=1}^{n} \frac{x_i^2}{\sigma_i^2} + \sqrt{\frac{a + b}{c + d}}$
        </div>

        <div class="formula success">
            <strong>Nuclear Notation with Text:</strong> $^{235}_{92}\text{U} + ^{1}_{0}\text{n} \rightarrow ^{236}_{92}\text{U}$
        </div>
    </div>

    <div class="test-section">
        <h3>Error Handling Test</h3>
        
        <div class="formula">
            <strong>Unmatched Braces:</strong> $x^{2 + y_{3} + z$
            <div class="description">This should be cleaned up automatically.</div>
        </div>

        <div class="formula">
            <strong>Extra Closing Braces:</strong> $x^{2}} + y_{3}}$
            <div class="description">This should be cleaned up automatically.</div>
        </div>

        <div class="formula">
            <strong>Empty Braces:</strong> $x^{} + y_{}$
            <div class="description">This should be handled gracefully.</div>
        </div>
    </div>

    <script>
        // Enhanced LaTeX renderer with error handling
        class EnhancedLatexRenderer {
            constructor() {
                this.isReady = true;
            }

            latexToHTML(latex) {
                if (!latex || typeof latex !== 'string') {
                    return '';
                }

                let html = latex.trim();
                
                // Remove LaTeX delimiters
                html = html.replace(/^\$\$|\$\$$/g, '').replace(/^\$|\$$/g, '');
                
                // Clean up any malformed expressions
                html = this.cleanupMalformedLatex(html);
                
                // Process complex expressions first (order matters)
                html = this.processComplexExpressions(html);
                
                // Then process basic symbols
                html = this.processBasicSymbols(html);
                
                return html;
            }

            cleanupMalformedLatex(html) {
                // Remove unmatched braces
                let braceCount = 0;
                let cleaned = '';
                
                for (let i = 0; i < html.length; i++) {
                    const char = html[i];
                    if (char === '{') {
                        braceCount++;
                        cleaned += char;
                    } else if (char === '}') {
                        if (braceCount > 0) {
                            braceCount--;
                            cleaned += char;
                        }
                        // Skip unmatched closing braces
                    } else {
                        cleaned += char;
                    }
                }
                
                // Add missing closing braces
                while (braceCount > 0) {
                    cleaned += '}';
                    braceCount--;
                }
                
                return cleaned;
            }

            processComplexExpressions(html) {
                try {
                    // Nuclear notation: ^{A}_{Z}X (handle various formats)
                    html = html.replace(/\^\{([^}]+)\}_\{([^}]+)\}([A-Za-z])/g, '<sup>$1</sup><sub>$2</sub>$3');
                    html = html.replace(/\^\{([^}]+)\}_\{([^}]+)\}\\text\{([^}]+)\}/g, '<sup>$1</sup><sub>$2</sub><span style="font-style: normal;">$3</span>');
                    
                    // Simple superscript with braces: ^{A}
                    html = html.replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>');
                    
                    // Simple subscript with braces: _{Z}
                    html = html.replace(/_\{([^}]+)\}/g, '<sub>$1</sub>');
                    
                    // Fractions with complex numerators/denominators
                    html = html.replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, (match, num, den) => {
                        const processedNum = this.processBasicSymbols(num);
                        const processedDen = this.processBasicSymbols(den);
                        return `<span style="display: inline-block; vertical-align: middle; text-align: center; margin: 0 2px;">
                            <span style="display: block; border-bottom: 1px solid; line-height: 1.2em; padding: 0 2px;">${processedNum}</span>
                            <span style="display: block; line-height: 1.2em; padding: 0 2px;">${processedDen}</span>
                        </span>`;
                    });
                    
                    // Square roots with complex content
                    html = html.replace(/\\sqrt\{([^}]+)\}/g, (match, content) => {
                        const processedContent = this.processBasicSymbols(content);
                        return `√<span style="text-decoration: overline;">${processedContent}</span>`;
                    });
                    
                    // Text formatting: \text{...}
                    html = html.replace(/\\text\{([^}]+)\}/g, '<span style="font-style: normal;">$1</span>');
                    
                    // Math mode: \mathrm{...}
                    html = html.replace(/\\mathrm\{([^}]+)\}/g, '<span style="font-family: serif;">$1</span>');
                    
                    // Bold: \mathbf{...}
                    html = html.replace(/\\mathbf\{([^}]+)\}/g, '<strong>$1</strong>');
                    
                    // Italic: \mathit{...}
                    html = html.replace(/\\mathit\{([^}]+)\}/g, '<em>$1</em>');
                    
                    // Subscripts and superscripts (handle nested cases)
                    html = this.processSubscriptsAndSuperscripts(html);
                    
                    return html;
                } catch (error) {
                    console.warn('Error processing complex expressions:', error);
                    return html;
                }
            }

            processSubscriptsAndSuperscripts(html) {
                try {
                    // Handle complex cases like ^{A-4}_{Z-2}
                    html = html.replace(/\^\{([^}]+)\}/g, '<sup>$1</sup>');
                    html = html.replace(/_\{([^}]+)\}/g, '<sub>$1</sub>');
                    
                    // Handle simple cases like x^2, y_i (but be more careful)
                    html = html.replace(/([A-Za-z0-9])\^([A-Za-z0-9])/g, '$1<sup>$2</sup>');
                    html = html.replace(/([A-Za-z0-9])_([A-Za-z0-9])/g, '$1<sub>$2</sub>');
                    
                    return html;
                } catch (error) {
                    console.warn('Error processing subscripts/superscripts:', error);
                    return html;
                }
            }

            processBasicSymbols(html) {
                try {
                    const conversions = [
                        // Greek letters
                        { pattern: /\\alpha/g, replacement: 'α' },
                        { pattern: /\\beta/g, replacement: 'β' },
                        { pattern: /\\gamma/g, replacement: 'γ' },
                        { pattern: /\\delta/g, replacement: 'δ' },
                        { pattern: /\\epsilon/g, replacement: 'ε' },
                        { pattern: /\\pi/g, replacement: 'π' },
                        { pattern: /\\sigma/g, replacement: 'σ' },
                        { pattern: /\\omega/g, replacement: 'ω' },
                        { pattern: /\\lambda/g, replacement: 'λ' },
                        { pattern: /\\mu/g, replacement: 'μ' },
                        { pattern: /\\nu/g, replacement: 'ν' },
                        { pattern: /\\hbar/g, replacement: 'ℏ' },
                        
                        // Math symbols
                        { pattern: /\\times/g, replacement: '×' },
                        { pattern: /\\pm/g, replacement: '±' },
                        { pattern: /\\leq/g, replacement: '≤' },
                        { pattern: /\\geq/g, replacement: '≥' },
                        { pattern: /\\neq/g, replacement: '≠' },
                        { pattern: /\\approx/g, replacement: '≈' },
                        { pattern: /\\partial/g, replacement: '∂' },
                        { pattern: /\\nabla/g, replacement: '∇' },
                        { pattern: /\\sum/g, replacement: '∑' },
                        { pattern: /\\int/g, replacement: '∫' },
                        { pattern: /\\infty/g, replacement: '∞' },
                        
                        // Arrows
                        { pattern: /\\rightarrow/g, replacement: '→' },
                        { pattern: /\\leftarrow/g, replacement: '←' },
                        
                        // Nuclear physics specific
                        { pattern: /\\bar\{([^}]+)\}/g, replacement: '<span style="text-decoration: overline;">$1</span>' },
                        { pattern: /\\vec\{([^}]+)\}/g, replacement: '<span style="text-decoration: overline;">$1</span>' },
                        { pattern: /\\hat\{([^}]+)\}/g, replacement: '<span style="text-decoration: overline;">$1</span>' },
                        { pattern: /\\tilde\{([^}]+)\}/g, replacement: '<span style="text-decoration: overline;">$1</span>' },
                        
                        // Units and measurements
                        { pattern: /\\text\{m\}/g, replacement: 'm' },
                        { pattern: /\\text\{kg\}/g, replacement: 'kg' },
                        { pattern: /\\text\{MeV\}/g, replacement: 'MeV' },
                        { pattern: /\\text\{c\}/g, replacement: 'c' },
                        
                        // Remove remaining LaTeX commands that we don't handle
                        { pattern: /\\[a-zA-Z]+\{[^}]*\}/g, replacement: '' },
                        { pattern: /\\[a-zA-Z]+/g, replacement: '' }
                    ];
                    
                    conversions.forEach(conv => {
                        try {
                            html = html.replace(conv.pattern, conv.replacement);
                        } catch (error) {
                            console.warn('Error applying conversion:', conv, error);
                        }
                    });
                    
                    return html;
                } catch (error) {
                    console.warn('Error processing basic symbols:', error);
                    return html;
                }
            }

            renderAllLatex(rootElement = document.body) {
                try {
                    const walker = document.createTreeWalker(
                        rootElement,
                        NodeFilter.SHOW_TEXT,
                        {
                            acceptNode: (node) => {
                                const text = node.textContent;
                                if (/\$[^$]+\$/.test(text) || /\$\$[^$]+\$\$/.test(text)) {
                                    return NodeFilter.FILTER_ACCEPT;
                                }
                                return NodeFilter.FILTER_REJECT;
                            }
                        }
                    );

                    const nodesToProcess = [];
                    let node;
                    while (node = walker.nextNode()) {
                        nodesToProcess.push(node);
                    }

                    nodesToProcess.forEach(textNode => {
                        try {
                            this.processTextNode(textNode);
                        } catch (error) {
                            console.warn('Error processing text node:', error);
                        }
                    });
                } catch (error) {
                    console.error('Error in renderAllLatex:', error);
                }
            }

            processTextNode(textNode) {
                const text = textNode.textContent;
                const parent = textNode.parentNode;
                
                if (parent.classList.contains('webtex-processed')) {
                    return;
                }

                const parts = this.splitByLatexPatterns(text);
                
                if (parts.length === 1) return;

                const container = document.createElement('span');
                container.classList.add('webtex-processed');

                parts.forEach(part => {
                    if (part.type === 'text') {
                        container.appendChild(document.createTextNode(part.content));
                    } else if (part.type === 'inline') {
                        const mathSpan = document.createElement('span');
                        mathSpan.classList.add('webtex-inline-math');
                        mathSpan.innerHTML = this.latexToHTML(part.original);
                        container.appendChild(mathSpan);
                    } else if (part.type === 'display') {
                        const mathDiv = document.createElement('div');
                        mathDiv.classList.add('webtex-display-math');
                        mathDiv.innerHTML = this.latexToHTML(part.original);
                        container.appendChild(mathDiv);
                    }
                });

                parent.replaceChild(container, textNode);
            }

            splitByLatexPatterns(text) {
                try {
                    const parts = [];
                    const patterns = [
                        { regex: /\$\$([^$]+)\$\$/g, type: 'display' },
                        { regex: /\$([^$]+)\$/g, type: 'inline' }
                    ];

                    let lastIndex = 0;
                    const matches = [];

                    patterns.forEach(pattern => {
                        const regex = new RegExp(pattern.regex.source, 'g');
                        let match;
                        while ((match = regex.exec(text)) !== null) {
                            matches.push({
                                index: match.index,
                                endIndex: match.index + match[0].length,
                                content: match[1],
                                original: match[0],
                                type: pattern.type
                            });
                        }
                    });

                    matches.sort((a, b) => a.index - b.index);

                    matches.forEach(match => {
                        if (match.index > lastIndex) {
                            parts.push({
                                type: 'text',
                                content: text.substring(lastIndex, match.index)
                            });
                        }

                        parts.push({
                            type: match.type,
                            content: match.content,
                            original: match.original
                        });

                        lastIndex = match.endIndex;
                    });

                    if (lastIndex < text.length) {
                        parts.push({
                            type: 'text',
                            content: text.substring(lastIndex)
                        });
                    }

                    return parts;
                } catch (error) {
                    console.warn('Error splitting LaTeX patterns:', error);
                    return [{ type: 'text', content: text }];
                }
            }
        }

        // Initialize and run the renderer
        document.addEventListener('DOMContentLoaded', () => {
            const renderer = new EnhancedLatexRenderer();
            renderer.renderAllLatex();
        });
    </script>
</body>
</html> 